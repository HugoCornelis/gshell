#!/usr/bin/perl
#!/usr/bin/perl -d:ptkdb -w
#


use strict;


BEGIN
{
    #! make check

    push @INC, '../perl';

    #! make distcheck

    push @INC, '../../perl';

    #! normal run

    push @INC, './perl';

    #! after install

    push @INC, '/usr/local/glue/swig/perl';

    # check for ".genesis3" directory. If not present we create
    # it and set a directory for perl inline code. 
    my $inline_path = "$ENV{HOME}/.genesis3/gshell/InlineCode";
    if(! -e $inline_path)
    {
      use File::Path;

      &File::Path::mkpath($inline_path);
    }

    $ENV{PERL_INLINE_DIRECTORY} = $inline_path;
}


use Data::Dumper;

use Getopt::Long;

use Term::ReadLine;

use Text::ParseWords;


$SIG{__DIE__}
    = sub {
	use Carp;

	confess @_;
    };


#t does not work, I guess because of readline handling it.

$SIG{INT}
    = sub {
	use Carp;

	confess @_;

	exit 1;
    };


our $option_verbose = 'warnings';

my $option_batch_mode;
my $option_execute = [];
my $option_output_tags = 0;

my $exit_code = 0;


sub interprete
{

    my $line = shift ;

    my @args = quotewords(" ", 1, $line);

    if($#args == -1)
    {
      return;
    }

    chomp @args;

    my $arguments = \@args;

#    my $arguments = [ split /\s/, $line, ];

    #t join hash and array arguments

    # create a perl function call

    my $quoted_line = $arguments->[0];

    if ($arguments->[1])
    {
	$quoted_line
	    .= (
		join
		' ',
		"(",
		(
		 map
		 {
		     (
		      /^('|")/
		      ? "$_, "
		      : "'$_',"
		     )
		  }
		 (@$arguments)[1 .. $#$arguments]
		),
		")"
	       );

	$quoted_line =~ s/\\n/\n/g;
    }

    if ($quoted_line =~ /^\s*(#.*)?$/)
    {
	return;
    }

    # start to prepare to execute of the command

    my $genesis_command;

    {
	$genesis_command = $arguments->[0];

	if ($option_output_tags)
	{
	    print "<" .  $genesis_command . ">\n";

	    my @args = @$arguments;

	    shift @args;

	    my $genesis_command_args = join " ", @args;

	    print "<args>\n" . $genesis_command_args . "\n</args>\n"
	}

	no strict "refs";

	if (!exists ((\%{"::"})->{"GENESIS3::"}->{"Commands::"}->{$genesis_command}))
	{
	    print "*** Error: command $genesis_command not found,\n*** Error: use 'list commands' to get a list of available commands,\n*** Error: use the help function to obtain help about each command\n";

	    if ($option_output_tags)
	    {
		print "</" .  $genesis_command . ">\n";
	    }

	    return;
	}
    }

    my $package = "GENESIS3::Commands::";

    $quoted_line =~ s/^\s*/$package/;

    my $result = eval($quoted_line);

    if ($@)
    {
	warn $@;

	print Data::Dumper->Dump( [ $result, ], [ 'Result', ]);
    }

    if ($result =~ /^\*\*\* Ok/)
    {

    }
    else
    {
	print "$result\n";
    }

    if ($option_output_tags)
    {
	print "</" .  $genesis_command . ">\n";
    }
}


sub loop
{
    my $historyfile = $ENV{HOME} . '/.phistory';

    my $term = Term::ReadLine->new('genesis > ');

    if (open H, $historyfile)
    {
	my %h;

	my @h = <H>;
	chomp @h;
	close H;

	$h{$_} = 1 foreach @h;
	$term->addhistory($_) foreach keys %h;
    }

    if ($option_output_tags)
    {

      my $line;

      while(<>){

	$line = $_;

	interprete($line);

	{
	    open H, ">>$historyfile";
	    print H "$line\n";
	    close H;
	}

	$term->addhistory($line) if /\S/;

      }

    }


    while ( defined ($_ = $term->readline("genesis > ")) )
    {
	my $line = $_;

	interprete($line);

	{
	    open H, ">>$historyfile";
	    print H "$line\n";
	    close H;
	}

	$term->addhistory($line) if /\S/;
    }
}




sub main
{
    if (!$ENV{NEUROSPACES_NMC_USER_MODELS}
	and !$ENV{NEUROSPACES_NMC_PROJECT_MODELS}
	and !$ENV{NEUROSPACES_NMC_SYSTEM_MODELS}
	and !$ENV{NEUROSPACES_NMC_MODELS})
    {
	$ENV{NEUROSPACES_NMC_MODELS} = '/usr/local/neurospaces/models/library';
    }

    read_cmd_line();

    require GENESIS3;

    GENESIS3::Commands::set_verbose($option_verbose);

    if (!$option_batch_mode)
    {
	GENESIS3::header();
    }

    STDOUT->autoflush(1);

    # process scripts given on the command line

    foreach my $script (@ARGV)
    {
	use IO::File;

	my $file = IO::File->new("<$script");

	my $lines = [ <$file>, ];

	foreach my $line (@$lines)
	{
	    #t do error processing

	    interprete($line);
	}
    }

    # process --execute arguments

    foreach my $line (@$option_execute)
    {
	#t do error processing

	interprete($line);
    }

    if (!$option_batch_mode)
    {
	loop();
    }
}


sub read_cmd_line
{
    my $option_help;
    my $option_version;

    my $result
	= GetOptions
	    (
	     "batch-mode!" => \$option_batch_mode,
	     "execute=s" => $option_execute,
	     "help!" => \$option_help,
	     "v|verbose=s" => \$option_verbose,
	     "version" => \$option_version,
	     "output-tags" => \$option_output_tags,
	    );

    if ($option_version)
    {
	require GENESIS3;

	my $version = GENESIS3::version();

	print $version . "\n";

	exit 1;
    }

    if ($option_help)
    {
	print
	    "
$0 <options>

$0: GENESIS 3 shell.

options:
    --batch-mode         batch mode, means that interactive mode is disabled.
    --execute            execute this string, may be given multiple times.
    --help               print usage information.
    --output-tags        Adds XML-like tags to diagnostic messages.
    --verbose            set verbosity level ('errors', 'warnings', 'information', 'debug', default is 'warnings').
    --version            give version information.

examples:
$0 --batch --execute \"echo '---\\n'\" --execute 'list commands'

";

	exit 0;
    }
}


main();


exit $exit_code;


